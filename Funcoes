Option Compare Database
'_____ Todo o projeto segue os seguintes modelos obrigatórios: _
    PascalCase: Variáveis de fácil entendimento e que seguem o padrão PascalCase
    
'Declara as variáveis globais
Dim rstTabela As DAO.Recordset
Dim ListaEmailErros As String 'Função IdentificaEmailsComErro atribui valor a variável | Função RetornaEmailsComErro exibe esses valores
Dim ListaCNPFNPJClienteErros As String 'Função IdentificaEmailsComErro atribui valor a variável | Função RetornaEmailsComErro exibe esses valores
   
   
   
Public Function TamanhoDoArquivo(NomeDoArquivo As String)
'Função que identifica o tamanho de um arquivo com base na sua localização (Pasta) e nome do arquivo
'Use essa função para validar o tamanho do arquivo que está sendo enviado por anexo e evitar problemas com o servidor

'Declara as variáveis locais
Dim FSO As Object
Dim Tamanho As Object

'Atribui a variável as propriedades do FileSystem
Set FSO = CreateObject("Scripting.FileSystemObject")

'Atribui a variável as propriedades do FileSistemObjects
Set Tamanho = FSO.GetFile(NomeDoArquivo)

'Retorna o tamanho do arquivo | Divide por 1000 para retorna o tamanho em KB | Round é usado para ñ retornar casas decimais
TamanhoDoArquivo = Round(Tamanho.Size / 1000)

End Function
  
  
  
Public Function RemoveArquivoExistente(Caminho As String, NomeDoArquivo As String)
'O arquivo será excluído se já existir na pasta destino
'Essa função não retorna nada apenas gerencia arquivos

'Se o arquivo já existe será excluido
If Dir(Caminho & NomeDoArquivo, vbArchive) <> vbNullString Then
    Kill Caminho & NomeDoArquivo
End If

End Function

  
Public Function EmiteAlertaTabelaSemDados(Campo As String, TabelaLocal As String, TabelaOracle As String, Automacao As String, Cliente As String, Periodicidade As String, Optional QtdeMinimaCaracteres As Integer = 0)
'Essa função verifica se uma tabela contém informações ou se o campo informado contém a qtde mínima de caracteres _
    Se não atender aos requisitos emite um alerta

'Verifica se o campo opcional está preenchido
If Len(QtdeMinimaCaracteres) <= 0 Then
    
    'Verifica se o campo não está vazio ou nulo
    QtdeLinhas = DCount("[" & Campo & "]", TabelaLocal, "[" & Campo & "] IS NOT NULL")
    
Else
    'Verifica se o campo tem a qtde de caracteres informada ou mais
    QtdeLinhas = DCount("[" & Campo & "]", TabelaLocal, "LEN([" & Campo & "]) >=" & QtdeMinimaCaracteres & "")
    
End If
    
'Se a Qtde de linhas é igual a 0, nulo ou vazio tenta buscar os dados novamente
'Se a qtde de linhas é menor que a qtde mínima de caracteres
If QtdeLinhas = 0 Then
    
    'Envia um e-mail de alerta
    Call Mdl_Emails.EnviaEmailAlertaTabelaVazia("erro.automacao@pd.tec.br", "tiago.goulart@pd.tec.br", Cliente, Automacao, TabelaLocal, TabelaOracle, Now)
    
Else
    
    'Se atende a todos os quesitos sai dessa função
    Exit Function

End If
    
End Function


Public Function CriaPastaDestino(CaminhoOrigem As String)
'Essa função cria pastas em um local especifico | Retorna o endereço com o novo caminho

'Se a pasta dentro do caminho + ano não existe cria a pasta
If Dir(CaminhoOrigem & Format(Date, "yyyy"), vbDirectory) = vbNullString Then MkDir (CaminhoOrigem & Format(Date, "yyyy"))

'Se a pasta dentro do caminho + ano + ano e mês não existe cria a pasta
If Dir(CaminhoOrigem & Format(Date, "yyyy") & "\" & Format(Date, "yyyymm"), vbDirectory) = vbNullString Then MkDir (CaminhoOrigem & Format(Date, "yyyy") & "\" & Format(Date, "yyyymm"))

'A variável do caminho recebe o caminho atualizado com o ano/ano e mês
CriaPastaDestino = CaminhoOrigem & Format(Date, "yyyy") & "\" & Format(Date, "yyyymm") & "\"


End Function


Public Sub RemoverPalavra(RemoveEssaPalavra As String, RemoveDessaTabela As Variant, RemoveComBaseNessaColuna As Variant)
'_____ Remove uma palavra específica de todas as linhas de um tabela específica

'Salva na variável a consulta dos dados da tabela com as filas
Set rstTabela = CurrentDb.OpenRecordset("SELECT " & RemoveComBaseNessaColuna & " FROM " & RemoveDessaTabela & "")

'Faça enquanto não chagar no ultimo valor da tabela
Do While rstTabela.EOF = False

    'Se a palavra Página for inserida na tabela exclui a linha _
        Esse problema ocorre no Excel, dificilmente no Access, mas como prevenção vamos remover
    If InStr(rstTabela(RemoveComBaseNessaColuna).Value, RemoveEssaPalavra) > 0 Then
        'Exclui a linha que tem a palavra
        rstTabela.Delete
    End If
    
    'Vai para a próxima linha da tabela
    rstTabela.MoveNext
Loop

End Sub

Public Sub RemoveVazios(RemoveDessaTabela As Variant, RemoveComBaseNessaColuna As Variant)
'_____ Delete uma linha específica que tenha um dado vazio

'Salva na variável a consulta dos dados da tabela com as filas
Set rstTabela = CurrentDb.OpenRecordset("SELECT " & RemoveComBaseNessaColuna & " FROM " & RemoveDessaTabela & "")

'Faça enquanto não chagar no ultimo valor da tabela
Do While rstTabela.EOF = False

    'Se for vazio exclui a linha _
        Esse problema ocorre no Excel, dificilmente no Access, mas como prevenção vamos remover
    If rstTabela(RemoveComBaseNessaColuna).Value = "" Or IsEmpty(rstTabela(RemoveComBaseNessaColuna).Value) = True Then
        'Exclui a linha vazia
        rstTabela.Delete
    End If
    
    'Vai para a próxima linha da tabela
    rstTabela.MoveNext
Loop

End Sub


Public Function CorrigeErrosDeEmails(Email As String)
'Essa função corrige possíveis erros nos e-mails cadastrados

CorrigeErrosDeEmails = Replace(Replace(Replace(Email, ",", ";"), "com.vê", "com.br"), ".@", "@")

End Function


Public Function IdentificaEmailsComErro(EmailCliente As String, CNPFNPJCliente As String) As Boolean
'Função que identifica erros nos e-mails cadastrados pelos clientes

'Declara as variáveis
Dim ListaErros
Dim EmailComErro As Boolean

'Se a variável Email não está vazia entra nessa condição
If IsEmpty(EmailCliente) = False And EmailCliente <> "" Then
       
    EmailComErro = False
    'Lista que recebe os possíveis erros nos e-mails | Sempre que identificar um novo erro inclua nessa lista
    ListaErros = Array(",", ".vê", ".@")
    
    'Itera sobre a lista dos erros
    For Each Erro In ListaErros
        'Se localizar algum erro retorna true e sai do laço
        If InStr(EmailCliente, Erro) > 0 Then EmailComErro = True: Exit For
    Next
    
    'Se a variável erro recebe verdadeiro
    If EmailComErro = True Then
        'Atribui as váriáveis GLOBAIS os dados de linha a linha e inclui uma tag <br> para pular linha
        ListaCNPFNPJClienteErros = CNPFNPJCliente & "<br>" & ListaCNPFNPJClienteErros
        ListaEmailErros = EmailCliente & "<br>" & ListaEmailErros
        'A função retorna verdadeiro
        IdentificaEmailsComErro = True
        'Sai da função
        Exit Function
    Else
        'A função retorna false | Significa que ñ tem erros
        IdentificaEmailsComErro = False
        'Sai da função
        Exit Function
    End If
    
Else

    'A função retorna verdadeiro | Significa que a variável Email está vazia
    IdentificaEmailsComErro = True
    'Sai da função
    Exit Function
End If
    
End Function


Public Function RetornaEmailsComErro()
'Essa função retorna o acumulado dos e-mail identificados com erro

'As duas variáveis dentro do array (vetor/lista) são globais _
    A cada nova iteração do código essas variáveis acumulam informação _
    Quando essa função for chamada no código vai retornar o acumulado das duas variáveis
RetornaEmailsComErro = Array(ListaCNPFNPJClienteErros, ListaEmailErros)

End Function


Public Function CorrigeErroAcentos(Palavra As String) As String
' Habilitar Microsoft Scripting Runtime
' A função faz um laço que vai "ler" as chaves do dicionário e comparar os erros de acentuação, localizando o erro, retorna a acentuação correta

' Declaração das variáveis
Dim Dict As New Dictionary

On Error Resume Next

' Atribuição dos valores ao dicionário
With Dict
    ' Definie o modo como as informação são comparadas (Comparação por texto)
    .CompareMode = TextCompare
    ' Primeira coluna KEY | Segunda coluna ITEM
    .Add Key:="Ã‡", Item:="Ç"
    .Add Key:="Ãˆ", Item:="È"
    .Add Key:="ú¿", Item:="Ú"
    .Add Key:="Ã‡", Item:="Ç"
    .Add Key:="Ãˆ", Item:="È"
    .Add Key:="Ã‰", Item:="É"
    .Add Key:="ÃŠ", Item:="Ê"
    .Add Key:="Ã‹", Item:="Ë"
    .Add Key:="ÃŒ", Item:="Ì"
    .Add Key:="ÃŽ", Item:="Î"
    .Add Key:="Ã‘", Item:="Ñ"
    .Add Key:="Ã’", Item:="Ò"
    .Add Key:="Ã“", Item:="Ó"
    .Add Key:="Ã”", Item:="Ô"
    .Add Key:="Ã•", Item:="Õ"
    .Add Key:="Ã–", Item:="Ö"
    .Add Key:="Ã™", Item:="Ù"
    .Add Key:="Ãš", Item:="Ú"
    .Add Key:="Ã›", Item:="Û"
    .Add Key:="Ãœ", Item:="Ü"
    .Add Key:="Ã¡", Item:="á"
    .Add Key:="Ã¢", Item:="â"
    .Add Key:="Ã£", Item:="ã"
    .Add Key:="Ã¤", Item:="ä"
    .Add Key:="Ã¥", Item:="å"
    .Add Key:="Ã§", Item:="ç"
    .Add Key:="Ã¨", Item:="è"
    .Add Key:="Ã©", Item:="é"
    .Add Key:="Ãª", Item:="ê"
    .Add Key:="Ã«", Item:="ë"
    .Add Key:="Ã¬", Item:="ì"
    .Add Key:="Ã­", Item:="í"
    .Add Key:="Ã®", Item:="î"
    .Add Key:="Ã¯", Item:="ï"
    .Add Key:="Ã°", Item:="ð"
    .Add Key:="Ã±", Item:="ñ"
    .Add Key:="Ã²", Item:="ò"
    .Add Key:="Ã³", Item:="ó"
    .Add Key:="Ã´", Item:="ô"
    .Add Key:="Ãµ", Item:="õ"
    .Add Key:="Ã¶", Item:="ö"
    .Add Key:="Ã¹", Item:="ù"
    .Add Key:="Ãº", Item:="ú"
    .Add Key:="Ã»", Item:="û"
    .Add Key:="Ã¼", Item:="ü"
    .Add Key:="Ã", Item:="ú"
    .Add Key:="Ã¿", Item:="Ú"
    .Add Key:="Âº", Item:="º"
    .Add Key:="ú¿", Item:="Ú"
End With

' For: O laço vai interar sobre as chaves do dicionário e salvar dentro da variável "acento"
For Each acento In Dict.Keys
    ' If: Se o erro de acento (variável) foi localizado na variável passada como parâmentro _
        Replace: Procura na palavra o acento, Dict retorna a acentuação correta de acordo com o acento (iterado lá no inicio com o For)
    If InStr(Palavra, acento) > 0 Then CorrigeErroAcentos = Replace(Palavra, acento, Dict.Item(acento)) Else CorrigeErroAcentos = Palavra: Exit Function
Next acento

End Function


